<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Three.js Starter</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  
  <div style="position:fixed; top:10px; left:10px; z-index:100; display:flex; flex-wrap:wrap; gap:8px; align-items:center; background:rgba(0,0,0,0.5); padding:8px; border-radius:6px; max-width:640px;">
    <button id="downloadObj" style="padding:6px 10px; background:#222; color:#fff; border:0; border-radius:4px; cursor:pointer;">Download OBJ</button>
    <label style="color:#fff; font-family:monospace;">Array Width: <input id="arrayWidth" type="range" min="1" max="100" value="8" style="vertical-align:middle;"></label>
    <span id="arrayWidthVal" style="color:#fff; min-width:28px; text-align:center;">8</span>
    <label style="color:#fff; font-family:monospace;">Array Height: <input id="arrayHeight" type="range" min="1" max="100" value="8" style="vertical-align:middle;"></label>
    <span id="arrayHeightVal" style="color:#fff; min-width:28px; text-align:center;">8</span>
    <label style="color:#fff; font-family:monospace;">Panel W: <input id="panelW" type="number" min="0.01" step="0.01" value="0.5" style="width:70px;"></label>
    <label style="color:#fff; font-family:monospace;">Panel H: <input id="panelH" type="number" min="0.01" step="0.01" value="0.5" style="width:70px;"></label>
    <label style="color:#fff; font-family:monospace;">Starting Angle: <input id="startingAngle" type="number" step="1" value="0" style="width:70px;"></label>
    <label style="color:#fff; font-family:monospace;">Start X: <input id="startX" type="number" step="0.1" value="0" style="width:70px;"></label>
    <label style="color:#fff; font-family:monospace;">Start Y: <input id="startY" type="number" step="0.1" value="0" style="width:70px;"></label>
    <label style="color:#fff; font-family:monospace; width:100%;">Panel Angles (deg, comma separated for each panel column): <input id="panelAngles" type="text" value="0,0,0,0,0,0,0,0" style="width:100%;"></label>
  </div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@latest/build/three.module.js';

  // 1. Scene
  const scene = new THREE.Scene();

  // inline OBJ exporter (no external scripts)
  function exportOBJ(scene) {
    let output = '';
    let vertexOffset = 0;
    const v = new THREE.Vector3();
    const n = new THREE.Vector3();
    const uv = new THREE.Vector2();

    scene.traverse(function(object) {
      if (object.isMesh) {
        const mesh = object;
        const geom = mesh.geometry;
        if (!geom) return;
        let position = geom.getAttribute('position');
        if (!position) return;

        output += 'o ' + (mesh.name || 'mesh') + '\n';

        // vertices
        for (let i = 0; i < position.count; i++) {
          v.fromBufferAttribute(position, i).applyMatrix4(mesh.matrixWorld);
          output += 'v ' + v.x + ' ' + v.y + ' ' + v.z + '\n';
        }

        // normals
        const normalAttr = geom.getAttribute('normal');
        if (normalAttr) {
          for (let i = 0; i < normalAttr.count; i++) {
            n.fromBufferAttribute(normalAttr, i).transformDirection(mesh.matrixWorld);
            output += 'vn ' + n.x + ' ' + n.y + ' ' + n.z + '\n';
          }
        }

        // uvs
        const uvAttr = geom.getAttribute('uv');
        if (uvAttr) {
          for (let i = 0; i < uvAttr.count; i++) {
            uv.fromBufferAttribute(uvAttr, i);
            output += 'vt ' + uv.x + ' ' + uv.y + '\n';
          }
        }

        // faces
        const index = geom.getIndex();
        if (index) {
          for (let i = 0; i < index.count; i += 3) {
            const a = index.getX(i) + 1 + vertexOffset;
            const b = index.getX(i + 1) + 1 + vertexOffset;
            const c = index.getX(i + 2) + 1 + vertexOffset;
            if (uvAttr && normalAttr) {
              output += 'f ' + a + '/' + a + '/' + a + ' ' + b + '/' + b + '/' + b + ' ' + c + '/' + c + '/' + c + '\n';
            } else if (uvAttr && !normalAttr) {
              output += 'f ' + a + '/' + a + ' ' + b + '/' + b + ' ' + c + '/' + c + '\n';
            } else if (!uvAttr && normalAttr) {
              output += 'f ' + a + '//' + a + ' ' + b + '//' + b + ' ' + c + '//' + c + '\n';
            } else {
              output += 'f ' + a + ' ' + b + ' ' + c + '\n';
            }
          }
        } else {
          // non-indexed
          for (let i = 0; i < position.count; i += 3) {
            const a = vertexOffset + i + 1;
            const b = vertexOffset + i + 2;
            const c = vertexOffset + i + 3;
            if (uvAttr && normalAttr) {
              output += 'f ' + a + '/' + a + '/' + a + ' ' + b + '/' + b + '/' + b + ' ' + c + '/' + c + '/' + c + '\n';
            } else if (uvAttr && !normalAttr) {
              output += 'f ' + a + '/' + a + ' ' + b + '/' + b + ' ' + c + '/' + c + '\n';
            } else if (!uvAttr && normalAttr) {
              output += 'f ' + a + '//' + a + ' ' + b + '//' + b + ' ' + c + '//' + c + '\n';
            } else {
              output += 'f ' + a + ' ' + b + ' ' + c + '\n';
            }
          }
        }

        vertexOffset += position.count;
      }
    });

    return output;
  }

  // 2. Camera
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 5;

  // 3. Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // (OrbitControls removed) simple static preview camera
  // Procedural mesh based on Unreal CreateMesh logic
  let planeMesh = null;
  const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x99ccff, side: THREE.DoubleSide, metalness:0.1, roughness:0.8 });

  function parsePanelAngles(text, expectedCount) {
    const parts = text.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
    // If not enough angles provided, pad with zeros
    while (parts.length < expectedCount) parts.push(0);
    return parts;
  }

  function createMesh(panelAngles, panels, panelDimensions, startingAngleDeg, startingPos) {
    // panels: {x: width count, y: height count}
    const vertices = [];
    const uvs = [];
    const indices = [];

    let cumulativeAngleDeg = startingAngleDeg;
    const nextPoint = new THREE.Vector3(startingPos.x, startingPos.y, startingPos.z || 0);
    let vectorPos = nextPoint.clone();

    // generate vertices and uvs
    for (let i = 0; i <= panels.x; i++) {
      if (i !== 0 && panelAngles[i - 1] !== undefined) {
        cumulativeAngleDeg += panelAngles[i - 1];
      }

      for (let j = 0; j <= panels.y; j++) {
        vectorPos = nextPoint.clone();
        vectorPos.z = j * panelDimensions.y;

        vertices.push(vectorPos.x, vectorPos.y, vectorPos.z);

        const U = i / panels.x;
        const V = j / panels.y;
        uvs.push(U, 1 - V);
      }

      const angleRad = cumulativeAngleDeg * Math.PI / 180.0;
      nextPoint.x = vectorPos.x + panelDimensions.x * Math.cos(angleRad);
      nextPoint.y = vectorPos.y + panelDimensions.x * Math.sin(angleRad);
      nextPoint.z = vectorPos.z;
    }

    // generate triangles
    for (let i = 0; i < panels.x; i++) {
      for (let j = 0; j < panels.y; j++) {
        const topLeft = i * (panels.y + 1) + j;
        const topRight = (i + 1) * (panels.y + 1) + j;
        const bottomLeft = i * (panels.y + 1) + (j + 1);
        const bottomRight = (i + 1) * (panels.y + 1) + (j + 1);

        indices.push(topLeft, topRight, bottomLeft);
        indices.push(topRight, bottomRight, bottomLeft);
      }
    }

    // build geometry
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    geom.setIndex(indices);
    geom.computeVertexNormals();

    if (planeMesh) {
      planeMesh.geometry.dispose();
      scene.remove(planeMesh);
    }

    planeMesh = new THREE.Mesh(geom, planeMaterial);
    planeMesh.name = 'ProceduralSection';
    scene.add(planeMesh);
  }

  // Wire UI
  const arrayWidthInput = document.getElementById('arrayWidth');
  const arrayHeightInput = document.getElementById('arrayHeight');
  const arrayWidthVal = document.getElementById('arrayWidthVal');
  const arrayHeightVal = document.getElementById('arrayHeightVal');
  const panelWInput = document.getElementById('panelW');
  const panelHInput = document.getElementById('panelH');
  const panelAnglesInput = document.getElementById('panelAngles');
  const startingAngleInput = document.getElementById('startingAngle');
  const startXInput = document.getElementById('startX');
  const startYInput = document.getElementById('startY');

  function rebuildFromUI() {
    const aw = Math.max(1, parseInt(arrayWidthInput.value, 10));
    const ah = Math.max(1, parseInt(arrayHeightInput.value, 10));
    arrayWidthVal.textContent = aw;
    arrayHeightVal.textContent = ah;

    const pw = parseFloat(panelWInput.value) || 1;
    const ph = parseFloat(panelHInput.value) || 1;
    const startingAngle = parseFloat(startingAngleInput.value) || 0;
    const startX = parseFloat(startXInput.value) || 0;
    const startY = parseFloat(startYInput.value) || 0;

    const panelAngles = parsePanelAngles(panelAnglesInput.value, aw);

    createMesh(panelAngles, { x: aw, y: ah }, { x: pw, y: ph }, startingAngle, { x: startX, y: startY, z: 0 });
  }

  arrayWidthInput.addEventListener('input', rebuildFromUI);
  arrayHeightInput.addEventListener('input', rebuildFromUI);
  panelWInput.addEventListener('input', rebuildFromUI);
  panelHInput.addEventListener('input', rebuildFromUI);
  panelAnglesInput.addEventListener('change', rebuildFromUI);
  startingAngleInput.addEventListener('input', rebuildFromUI);
  startXInput.addEventListener('input', rebuildFromUI);
  startYInput.addEventListener('input', rebuildFromUI);

  // initial build
  rebuildFromUI();

  // Attach OBJ download handler once
  const downloadBtn = document.getElementById('downloadObj');
  downloadBtn.addEventListener('click', () => {
    scene.updateMatrixWorld(true);
    const objText = exportOBJ(scene);
    const blob = new Blob([objText], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'scene.obj';
    link.click();
    URL.revokeObjectURL(link.href);
  });

  // Lights
  const ambient = new THREE.AmbientLight(0x404040, 1.2);
  scene.add(ambient);
  const directional = new THREE.DirectionalLight(0xffffff, 0.8);
  directional.position.set(3, 10, 3);
  scene.add(directional);

  // Handle resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Render loop
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
</script>

</body>
</html>
